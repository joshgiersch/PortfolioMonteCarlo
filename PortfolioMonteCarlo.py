import numpy as np
import math
from scipy.stats import norm


def create_price_trajectories(S, T, mu, vol, number_of_sims):
    #S: starting price
    #T: number of days to simulate
    #mu: annualised mean return
    #vol: annualised daily vol
    price_trajectories = []
    for i in range(number_of_sims):
        # create list of daily returns using random normal distribution
        daily_returns = np.random.normal(mu / 365, vol / math.sqrt(365), T) + 1
        # set starting price and create price series generated by above random daily returns
        price_list = [S]

        for x in daily_returns:
            price_list.append(price_list[-1] * x)

        price_trajectories.append(price_list)

    return price_trajectories

starting_price = 100
number_of_sims = 1000
days_to_simulate = 3650
cash_rate = 0.01125

ES3_return = 0.06
ES3_vol = 0.105
A35_return = 0.02
A35_vol = 0.035

# create price trajectories for three assets
#

stock_returns = create_price_trajectories(starting_price,days_to_simulate,ES3_return,ES3_vol,number_of_sims)
bond_returns = create_price_trajectories(starting_price,days_to_simulate,A35_return,A35_vol,number_of_sims)
cash_return = starting_price * ((1+cash_rate)**(days_to_simulate/365))

n=0

for i in range(number_of_sims):
    #for each simulation, find the terminal value of a portfolio that's...
    #100% in a 70-30 - what percentage of the time does it beat cash?
    #100% in a 60-40 - what percentage of the time does it beat cash? ... etc etc.
    #for starters: just do the 100%-in-a-70-30
    if (0.8 * stock_returns[i][-1] + 0.2 * bond_returns[i][-1]) > cash_return:
        n += 1

print(n/number_of_sims)
